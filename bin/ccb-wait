#!/usr/bin/env python3
"""
ccb-wait - Wait for multiple requests to complete, then fetch replies.

Usage:
    ccb-wait <request_id> [request_id ...]
    echo "id1 id2" | ccb-wait
    ccb-wait -f ids.txt

Options:
    -f, --file FILE   Read request IDs from file (one per line)
    --interval SEC    Poll interval in seconds (default: 2)
    --timeout SEC     Max wait time in seconds (default: 0 = no timeout)
    --verbose         Print progress to stderr
    --json            Output raw JSON replies
"""
from __future__ import annotations

import argparse
import json
import os
import sys
import time
import urllib.request
import urllib.error
from typing import List, Tuple, Optional


DONE_STATUSES = {"completed", "failed", "timeout"}


def get_gateway_url() -> str:
    return os.environ.get("CCB_GATEWAY_URL", "http://localhost:8765")


def read_ids_from_file(path: str) -> List[str]:
    try:
        with open(path, "r", encoding="utf-8") as handle:
            return [line.strip() for line in handle if line.strip()]
    except Exception as exc:
        print(f"Error: Failed to read file: {exc}", file=sys.stderr)
        return []


def read_ids_from_stdin() -> List[str]:
    data = sys.stdin.read()
    return [token for token in data.split() if token.strip()]


def post_json(url: str, payload: dict, timeout_s: float = 10.0) -> Tuple[Optional[dict], Optional[str]]:
    try:
        req = urllib.request.Request(
            url,
            data=json.dumps(payload).encode(),
            headers={"Content-Type": "application/json"},
            method="POST",
        )
        with urllib.request.urlopen(req, timeout=timeout_s) as response:
            return json.loads(response.read().decode()), None
    except urllib.error.HTTPError as exc:
        body = exc.read().decode() if exc.fp else ""
        return None, f"HTTP {exc.code}: {body or exc.reason}"
    except urllib.error.URLError as exc:
        return None, f"Cannot connect to gateway: {exc}"
    except Exception as exc:
        return None, str(exc)


def format_header(result: dict) -> str:
    request_id = result.get("request_id", "")
    if not result.get("found", False):
        return f"=== {request_id} (not_found) ==="
    provider = result.get("provider") or "unknown"
    status = result.get("status") or "unknown"
    return f"=== {request_id} ({provider}) [{status}] ==="


def wait_until_done(request_ids: List[str], interval_s: float, timeout_s: float, verbose: bool) -> Optional[str]:
    gateway_url = get_gateway_url()
    start = time.time()

    while True:
        data, error = post_json(f"{gateway_url}/api/batch/status", {"request_ids": request_ids})
        if error:
            return error

        results = data.get("results", [])
        pending = [
            r for r in results
            if r.get("found", False) and r.get("status") not in DONE_STATUSES
        ]

        if not pending:
            return None

        if timeout_s and (time.time() - start) >= timeout_s:
            return f"Timeout after {timeout_s}s: {len(pending)} requests still pending"

        if verbose:
            pending_ids = ", ".join(r.get("request_id", "")[:8] for r in pending)
            print(f"Pending {len(pending)}/{len(results)}: {pending_ids}", file=sys.stderr)

        time.sleep(interval_s)


def main() -> int:
    parser = argparse.ArgumentParser(prog="ccb-wait", description="Wait for multiple requests to complete.")
    parser.add_argument("request_ids", nargs="*", help="Request IDs to wait for")
    parser.add_argument("-f", "--file", help="Read request IDs from file (one per line)")
    parser.add_argument("--interval", type=float, default=2.0, help="Poll interval in seconds")
    parser.add_argument("--timeout", type=float, default=0.0, help="Max wait time in seconds (0 = no timeout)")
    parser.add_argument("--verbose", action="store_true", help="Print progress to stderr")
    parser.add_argument("--json", action="store_true", help="Output raw JSON replies")
    args = parser.parse_args()

    request_ids: List[str] = []
    if args.file:
        request_ids.extend(read_ids_from_file(args.file))
    request_ids.extend([rid for rid in args.request_ids if rid.strip()])

    if not request_ids and not sys.stdin.isatty():
        request_ids.extend(read_ids_from_stdin())

    request_ids = [rid for rid in request_ids if rid]

    if not request_ids:
        print("Usage: ccb-wait <request_id> [request_id ...]", file=sys.stderr)
        return 1

    error = wait_until_done(request_ids, args.interval, args.timeout, args.verbose)
    if error:
        print(f"Error: {error}", file=sys.stderr)
        return 2

    gateway_url = get_gateway_url()
    data, error = post_json(f"{gateway_url}/api/batch/reply", {"request_ids": request_ids})
    if error:
        print(f"Error: {error}", file=sys.stderr)
        return 1

    if args.json:
        print(json.dumps(data, ensure_ascii=False, indent=2))
        return 0

    for result in data.get("results", []):
        print(format_header(result))
        if not result.get("found", False):
            print("Error: Request not found")
            print()
            continue

        response = result.get("response")
        error_msg = result.get("error")

        if response:
            print(response)
        elif error_msg:
            print(f"Error: {error_msg}")
        else:
            print("(no response)")
        print()

    return 0


if __name__ == "__main__":
    sys.exit(main())
